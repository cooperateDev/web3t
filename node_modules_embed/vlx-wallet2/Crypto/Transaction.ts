import HDKeys from './HDKeys';
import * as bs58 from 'bs58';
import * as _ from 'lodash';

import * as crypto from "crypto";
import { BigInteger } from "big-integer";
import * as bigInt from 'big-integer';
import {BigIntToBufferLE, toBigInt, VLXtoSatoshi} from "./utils";
import {
    TransactionBase,
    TransactionDto,
    TransactionInput, TransactionInputDto,
    TransactionOutput,
    TransactionOutputDto
} from "./Dto/Transaction";
import {ContractData, ContractDataDto, ContractMessage, ContractMessageDto} from "./Dto/ContractData";

enum Errors {
    ValueMustBeGreaterThatCommission = "value must be greater then commission",
    InsufficientFunds = "amount + commission smaller than value",
}

export default class Transaction extends TransactionBase {

    private sodium;
    private signers: { [address: string]: HDKeys } = {};

    constructor(sodium) {
        super();
        this.sodium = sodium;
        this.tx_in = [];
        this.tx_out = [];
    }

    public AddSender(address: string, keyPair: HDKeys, value: BigInteger, nonce: BigInteger, commission: BigInteger) {
        if (value < commission) {
            throw new Error(Errors.ValueMustBeGreaterThatCommission);
        }
        this.tx_in = [...this.tx_in, new TransactionInput(address, value, nonce, commission, keyPair.publicKey)];
        this.signers[address] = keyPair;
    }

    public AddReceiver(address: string, value: BigInteger) {
        this.tx_out = [...this.tx_out, new TransactionOutput(address, value, this.tx_out.length)];
    }

    private checkContractsData() {
        if (this.contracts == null) {
            this.contracts = new ContractData();
        }
    }

    public AddContractCreation(sender: string, code: string, amount: BigInteger, commission: BigInteger) {
        this.checkContractsData();

        this.contracts.messages = [...this.contracts.messages, new ContractMessage(sender, null, code, amount, commission)];
    }

    public AddContractExecute(sender: string, address: string, code: string, amount: BigInteger, commission: BigInteger) {
        this.checkContractsData();

        this.contracts.messages = [...this.contracts.messages, new ContractMessage(sender, address, code, amount, commission)];
    }

    public sign(): Transaction {
        this.tx_in.forEach(txIn => {
            const sigMsg = this.msgForSignUser(txIn.address, txIn.value, txIn.commission, txIn.nonce);

            const pk = Buffer.from(this.signers[txIn.address].privateKey, 'hex');

            const sigUintArray = this.sodium.crypto_sign_detached(sigMsg, pk);
            txIn.sign = Buffer.from(sigUintArray).toString('hex');
        });

        this.hash = this.generateHash();
        return this;
    };

    public signAndToJson(): string {
        const txSigned = this.sign();
        return txSigned.ToJSON();
    }

    public ToJSON(): string {
        const t = new ContractDataDto<number>();

        let contracts = new ContractDataDto<number>();
        if (this.contracts != null && this.contracts.messages != null) {
            contracts = {
                messages: this.contracts.messages.map((msg): ContractMessageDto<number> => (
                    {
                        ..._.pick(msg, ['sender', 'address', 'payload']),
                        commission: Number(msg.commission),
                        value: Number(msg.value),
                    }
                )),
                state_transitions: this.contracts.state_transitions,
            };
        }

        const tx: TransactionDto<number> = {
            ..._.pick(this, ['hash', 'version', 'lock_time']),
            tx_in: this.tx_in.map((txIn) : TransactionInputDto<number> => (
                {
                    ..._.pick(txIn, ['type', 'address', 'sign', 'public_key']),
                    // ...txIn,
                    // public_key: Buffer.from(txIn.public_key, 'hex').toString('base64'),
                    value: Number(txIn.value),
                    nonce: Number(txIn.nonce),
                    commission: Number(txIn.commission),
                }
            )),
            tx_out: this.tx_out.map((txOut): TransactionOutputDto<number> => (
                {
                    ..._.pick(txOut, ['type', 'address', /*'node_id',*/ 'index']),
                    value: Number(txOut.value)
                }
            )),
            contracts: contracts,
        };

        return JSON.stringify(tx);
    };

    private generateHash() : string {
        let payload = Buffer.alloc(8);
        payload.writeUInt32LE(this.version, 0);
        payload.writeUInt32LE(this.lock_time, 4);

        const txInSlice = this.MsgForSignInputsUser();

        const txOutSlice = this.MsgForSignOutputs();

        // contracts
        let contractPayload = Buffer.alloc(0);
        if (this.contracts != null && this.contracts.messages != null) {
            contractPayload = this.contracts.MsgForSignUser();
        }

        payload = Buffer.concat([payload, txInSlice, txOutSlice, contractPayload]);

        return Transaction.doubleSha256(payload);
    }

    private msgForSignUser(address: string, value: BigInteger, commission: BigInteger, nonce: BigInteger) {
        const txOutSlice = this.MsgForSignOutputs();

        let contractPayload = Buffer.alloc(0);
        if (this.contracts != null && this.contracts.messages != null) {
            contractPayload = this.contracts.MsgForSignUser();
        }
        return this.msgForSign(address, value, commission, nonce, txOutSlice, contractPayload);
    }

    private msgForSign(address: string, value: BigInteger, commission: BigInteger, nonce: BigInteger,
                       txOutSlice: Buffer, contractPayload: Buffer) {
        const addr = bs58.decode(address); // Buffer.from(address, 'hex'); // 26 bytes
        const val = BigIntToBufferLE(value, 8);
        const comm = BigIntToBufferLE(commission, 8);
        const non = BigIntToBufferLE(nonce, 8);

        let buf = Buffer.alloc(8);
        buf.writeUInt32LE(this.version, 0);
        buf.writeUInt32LE(this.lock_time, 4);

        return Buffer.concat([addr, val, comm, non, buf, txOutSlice, contractPayload]);
    }

    private MsgForSignInputsUser() : Buffer {
        return this.tx_in.reduce((res, txIn) => {
            return txIn.type === 0 ? Buffer.concat([res, txIn.ToBytes()]) : Buffer.alloc(0);
        }, Buffer.alloc(0));
    }

    // func MsgForSign(tos []TransactionOutput) in go
    private MsgForSignOutputs() : Buffer {
        return this.tx_out.reduce((res, txOut) => {
            return txOut.type === 0 ? Buffer.concat([res, txOut.ToBytes()]) : Buffer.alloc(0);
        }, Buffer.alloc(0));
    }

    private static doubleSha256(val: Buffer): string {
        const first = crypto.createHash('sha256').update(val).digest();
        const second = crypto.createHash('sha256').update(first).digest();
        return second.toString('hex');
    }

}
