import * as bs58 from 'bs58';
import * as keccak256 from 'keccak256';
import { BigInteger } from "big-integer";

const M = 100000000;
const MCountSymbols = 9;
import * as bigInt from 'big-integer';
import * as crypto from "crypto";

const addressChecksumLen = 4;
const ContractVersion = Buffer.from(new Uint8Array([16, 3]));

export const satoshiToVLX = (value: number): number => {
	return value / M;
};

export const toBigInt = (value: number): BigInteger => {
	return bigInt(value);
};

export const VLXtoSatoshi = (value: number): BigInteger => {
	const str = value.toString();
	const dotIndex = str.indexOf('.');
	if (dotIndex == -1) {
		return bigInt(value).multiply(bigInt(M));
	}
	let strConverted = str.replace('.', '');
	if (str.indexOf('0.') === 0) {
		strConverted = str.replace('0.', '');
	}

	if (MCountSymbols - str.length + dotIndex < 0) throw new Error('value smaller then satoshi');
	const strConverted2 = addZeroToEnd(strConverted, MCountSymbols - str.length + dotIndex);
	return bigInt(strConverted2);
};

const addZeroToEnd = (str: string, count: number): string => {
	let newStr = str;
	for (let i = 0; i < count; i++) {
		newStr += '0';
	}
	return newStr;
};

export const BigIntToBufferLE = (val: BigInteger, size: number): Buffer => {
	const arr = val.toArray(256).value;
	const buf = Buffer.alloc(size);
	buf.set(arr.reverse());
	return buf
};

export const BigIntToBufferBE = (val: BigInteger, size: number): Buffer => {
	const arr = val.toArray(256).value;
	const buf = Buffer.alloc(size);
	buf.set(arr);
	return buf
};

export const NewContractAddress = (address: string, nonce: BigInteger): string => {
	const addr = bs58.decode(address);
	const non = BigIntToBufferBE(nonce, 8);
	const k = keccak256(Buffer.concat([addr, non]));
	return NewAddress(k, ContractVersion);
};


export const NewAddress = (publicKey: Buffer, prefix: Buffer): string => {
	let payload = Buffer.alloc(0);
	payload = Buffer.concat([payload, prefix]);
	const pub256Key = crypto.createHash('sha256').update(publicKey).digest();
	const ripmd160 = crypto.createHash('ripemd160').update(pub256Key).digest();
	payload = Buffer.concat([payload, ripmd160]);
	const checksum = MakeChecksum(payload);

	payload = Buffer.concat([payload, checksum]);
	return bs58.encode(payload);
};

export const MakeChecksum = (payload: Buffer): Buffer => {
	const firstSha256 = crypto.createHash('sha256').update(payload).digest();
	const secondSha256 = crypto.createHash('sha256').update(firstSha256).digest();
	const checksum = Buffer.alloc(4);
	secondSha256.copy(checksum, 0, 0, addressChecksumLen);
	return checksum;
};
