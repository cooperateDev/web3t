import { BigInteger } from "big-integer";
import { BigIntToBufferLE } from "../utils";
import * as bs58 from 'bs58';
import {ContractData, ContractDataDto} from "./ContractData";

export class TransactionInputDto<T> {

    type: number = 0;   // uint32
    address: string;    // [26]byte
    value: T;           // uint64
    sign: string;       // []byte
    public_key: string; // [32]byte
    nonce: T;           // uint64
    commission: T;      // uint64

    constructor(address: string, value: T, nonce: T, commission: T, pubKey: string) {
        this.address = address;
        this.value = value;
        this.nonce = nonce;
        this.commission = commission;
        this.public_key = pubKey;
    }
}

export class TransactionInput extends TransactionInputDto<BigInteger> {
    ToBytes(): Buffer {
        let payload = Buffer.alloc(4); // 4 + 26 + 8 + 8
        payload.writeUInt32LE(this.type, 0); // 4 bytes
        const addr = bs58.decode(this.address); // Buffer.from(this.address, 'hex'); // 26 bytes
        const value = BigIntToBufferLE(this.value, 8);
        const nonce = BigIntToBufferLE(this.nonce, 8);

        let sign = Buffer.alloc(0);
        let pubKey = Buffer.alloc(0);
        if (this.sign != null && this.public_key != null) {
            sign = Buffer.from(this.sign, 'hex');
            pubKey = Buffer.from(this.public_key, 'hex');
        }

        return Buffer.concat([payload, addr, value, nonce, sign, pubKey]);
    }
}

export class TransactionOutputDto<T> {

    index: number;      // uint32
    type: number = 0;   // uint32
    value: T;  // uint64
    address: string;    // [26]byte
    // node_id: string; // = '0000000000000000000000000000000000000000000000000000000000000000';    // [32]byte

    constructor(address: string, value: T, index: number) {
        this.address = address;
        this.value = value;
        this.index = index;
    }
}

export class TransactionOutput extends TransactionOutputDto<BigInteger> {
    ToBytes(): Buffer {
        let payload = Buffer.alloc(8); // 4 + 26 + 8 + 8
        payload.writeUInt32LE(this.index, 0); // 4 bytes
        payload.writeUInt32LE(this.type, 4); // 4 bytes

        const value = BigIntToBufferLE(this.value, 8);
        const addr = bs58.decode(this.address); // Buffer.from(this.address, 'hex');
        // const node_id = Buffer.from(this.node_id, 'hex');
        // let node_id = Buffer.alloc(0);
        // if (this.node_id != null) {
        //     node_id = Buffer.from(this.node_id, 'hex');
        // }

        return Buffer.concat([payload, value, addr/*, node_id*/]);
    }
}

export class TransactionDto<T> {
    hash: string; // [32]byte
    version = 2; // uint32
    lock_time = 0; // uint32
    tx_in: TransactionInputDto<T>[];
    tx_out: TransactionOutputDto<T>[];
    contracts: ContractDataDto<T>;
}

export class TransactionBase extends TransactionDto<BigInteger> {
    tx_in: TransactionInput[];
    tx_out: TransactionOutput[];
    contracts: ContractData;
}
