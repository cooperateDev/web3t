import * as crypto from "crypto";
import VelasCrypto from "./Crypto";
import Wallet from "./Crypto/Wallet";
import {satoshiToVLX, toBigInt, VLXtoSatoshi} from "./Crypto/utils";
import * as bigInt from "big-integer";

const COMMISSION = bigInt(100000);
const DOUBLE_COMMISSION = bigInt(200000);
const SATOSHI = bigInt(100000000);

export default class {

    static async fromSeedAsync(seed, path) {
        let vc = await VelasCrypto.init();
        return vc.keysGen.fromSeed(seed, 'm/' + path + '\'').toWallet();
    }

    static fromSeed(seed, path) {
        return VelasCrypto.init().then(vc=>{
            return vc.keysGen.fromSeed(seed, 'm/' + path + '\'');//.toWallet();
        });
    }

    static IsValidAddress(address) {
        return Wallet.IsValidAddress(address);
    }

    static tx(nonce, seed, pathIndex, address, amount) {
        // const un = unspent.map(out => ({ ...out, value: bigInt(out.value) }))
        return VelasCrypto.init().then(vc => {
            const hdKeys = vc.keysGen.fromSeed(seed, 'm/' + pathIndex + '\'');
            const wallet = hdKeys.toWallet();

            const txEmpty = vc.tx.generateTx();
            txEmpty.AddSender(wallet.Base58Address, hdKeys, toBigInt(amount).multiply(SATOSHI).plus(COMMISSION), toBigInt(nonce), COMMISSION);

            txEmpty.AddReceiver(address, toBigInt(amount).multiply(SATOSHI));

            // const txUnsigned = vc.tx.generate(
            //     un,
            //     VLXtoSatoshi(amount),
            //     hdKeys,
            //     wallet.Base58Address,
            //     address,
            //     bigInt(COMMISSION)
            // );

            const txSigned = txEmpty.sign();
            return txSigned;
        });
    }

    static async createContract(nonce, seed, pathIndex, code, amount, fee) {
        return VelasCrypto.init().then(vc => {
            const hdKeys = vc.keysGen.fromSeed(seed, 'm/' + pathIndex + '\'');
            const wallet = hdKeys.toWallet();

            const txEmpty = vc.tx.generateTx();

            const commission = VLXtoSatoshi(fee); // .plus(COMMISSION);
            txEmpty.AddSender(wallet.Base58Address, hdKeys, toBigInt(amount).multiply(SATOSHI).plus(commission.plus(COMMISSION)), toBigInt(nonce), COMMISSION);

            txEmpty.AddContractCreation(wallet.Base58Address, code, toBigInt(amount).multiply(SATOSHI), commission);

            const txSigned = txEmpty.sign();

            console.log(txSigned)

            return txEmpty;
        });
    }

    static executeContract(nonce, seed, pathIndex, address, code, amount) {
        return VelasCrypto.init().then(vc => {
            const hdKeys = vc.keysGen.fromSeed(seed, 'm/' + pathIndex + '\'');
            const wallet = hdKeys.toWallet();

            const txEmpty = vc.tx.generateTx();
            txEmpty.AddSender(wallet.Base58Address, hdKeys, toBigInt(amount).multiply(SATOSHI).plus(DOUBLE_COMMISSION), toBigInt(nonce), COMMISSION);

            txEmpty.AddContractExecute(wallet.Base58Address, address, code, toBigInt(amount).multiply(SATOSHI), COMMISSION);

            const txSigned = txEmpty.sign();
            return txSigned;
        });
    }

}
